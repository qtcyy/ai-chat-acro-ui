# AuthProvider 开发者指南

## 快速开始

本指南帮助开发者理解和维护 AuthProvider 认证系统的实现。

## 架构概览

### 核心设计模式

AuthProvider 采用以下设计模式：

- **观察者模式**: 使用 RxJS BehaviorSubject 管理用户输入
- **发布订阅模式**: 通过 Observable 处理异步认证流程  
- **上下文模式**: 使用 React Context 在组件间共享认证状态
- **策略模式**: 不同类型的认证错误采用不同处理策略

### 技术栈

```typescript
// 核心依赖
import { BehaviorSubject, Observable, combineLatest } from 'rxjs';
import { createContext, useContext } from 'react';
import { useHttp, HttpLoading } from 'utils';
```

## 核心概念

### 1. 响应式表单验证

```typescript
// BehaviorSubject 用于实时捕获用户输入
const [username$] = useState(() => new BehaviorSubject(""));
const [password$] = useState(() => new BehaviorSubject(""));

// 组合验证逻辑
useEffect(() => {
  const subscription = combineLatest([username$, password$]).pipe(
    debounceTime(300),
    distinctUntilChanged(),
    map(([username, password]) => ({
      usernameValid: username.length >= 6,
      passwordValid: password.length >= 8,
      formValid: username.length >= 6 && password.length >= 8
    }))
  ).subscribe((validation) => {
    setLoginValidation(validation);
  });

  return () => subscription.unsubscribe();
}, [username$, password$]);
```

**关键洞察**: 
- `debounceTime(300)` 避免频繁验证
- `distinctUntilChanged()` 防止重复计算
- `combineLatest` 确保任一字段变化都触发验证

### 2. 认证状态管理

```typescript
type AuthState = {
  loading: boolean;       // 请求进行中
  error: AuthError | null; // 错误信息
  isAuthed: boolean;      // 认证状态
  username: string | null; // 当前用户
  role: string | null;    // 用户角色
};
```

**状态转换图**:
```
初始状态 → 加载中 → 认证成功/失败
   ↓         ↓         ↓
未认证    loading    已认证/错误状态
```

### 3. 错误处理策略

```typescript
const handleLoginError = (error: string): AuthError => {
  // 根据错误类型返回不同的错误码
  return {
    message: error,
    code: error.includes("网络") ? 0 : 400
  };
};
```

## API 设计原则

### 1. 接口一致性

所有 API 响应都遵循统一格式：

```typescript
type BaseResponse = {
  code: number;    // 状态码：200 成功，其他失败
  msg: string;     // 消息描述
};
```

### 2. 类型安全

```typescript
// 强类型定义防止运行时错误
type LoginResponse = BaseResponse & {
  token: string;
  userId: string;
  username: string;
  role: string;
  sessionInfo?: any;
};
```

### 3. Observable 链式调用

```typescript
const login = (): Observable<LoginResponse> => {
  return postBody.pipe(
    switchMap((body) => http.post<LoginResponse>(url, body)),
    tap((response) => {
      // 副作用：更新状态
      if (response.code === 200) {
        setAuthState(prev => ({ ...prev, isAuthed: true }));
      }
    }),
    catchError((error) => {
      // 错误处理
      return throwError(() => handleLoginError(error));
    })
  );
};
```

## 最佳实践

### 1. 内存管理

**问题**: BehaviorSubject 和 Observable 订阅可能导致内存泄漏

**解决方案**:
```typescript
useEffect(() => {
  const subscription = observable.subscribe();
  
  return () => {
    subscription.unsubscribe(); // 清理订阅
  };
}, []);

// 组件卸载时完成 Subject
useEffect(() => {
  return () => {
    username$.complete();
    password$.complete();
  };
}, []);
```

### 2. 错误边界

```typescript
// 为 AuthProvider 添加错误边界
const withErrorBoundary = (Component) => {
  return class extends React.Component {
    componentDidCatch(error, errorInfo) {
      console.error('AuthProvider error:', error, errorInfo);
    }
    
    render() {
      return <Component {...this.props} />;
    }
  };
};
```

### 3. 性能优化

**避免不必要的重新渲染**:
```typescript
// 使用 useMemo 缓存计算结果
const contextValue = useMemo(() => ({
  loginValidation,
  login,
  authState,
  updateUsername,
  updatePassword
}), [loginValidation, authState]);

return (
  <AuthContext.Provider value={contextValue}>
    {children}
  </AuthContext.Provider>
);
```

## 调试技巧

### 1. RxJS 调试

```typescript
// 使用 tap 操作符添加调试信息
const login = () => {
  return postBody.pipe(
    tap(body => console.log('Login request:', body)),
    switchMap(body => http.post(url, body)),
    tap(response => console.log('Login response:', response)),
    // ... 其他操作
  );
};
```

### 2. 状态调试

```typescript
// 添加状态变化监听
useEffect(() => {
  console.log('Auth state changed:', authState);
}, [authState]);
```

### 3. 网络请求调试

```typescript
// 在 catch 中添加详细错误信息
catchError((error) => {
  console.error('Login failed:', {
    status: error.status,
    statusText: error.statusText,
    url: error.url,
    message: error.message
  });
  return throwError(() => error);
})
```

## 测试策略

### 1. 单元测试

```typescript
// 测试验证逻辑
describe('AuthProvider validation', () => {
  it('should validate username length', () => {
    const username$ = new BehaviorSubject('test');
    const isValid = username$.pipe(
      map(value => value.length >= 6)
    );
    
    // 测试验证逻辑
  });
});
```

### 2. 集成测试

```typescript
// 测试完整的登录流程
describe('Login flow', () => {
  it('should handle successful login', async () => {
    // 模拟成功的 HTTP 响应
    const mockResponse = { code: 200, token: 'test-token' };
    
    // 测试登录流程
  });
});
```

### 3. E2E 测试

```typescript
// Cypress 测试示例
describe('Authentication', () => {
  it('should login successfully', () => {
    cy.visit('/login');
    cy.get('[data-testid="username"]').type('testuser');
    cy.get('[data-testid="password"]').type('password123');
    cy.get('[data-testid="login-btn"]').click();
    cy.url().should('include', '/chat/home');
  });
});
```

## 常见问题解决

### 1. "Http not init" 错误

**原因**: `useHttp` hook 返回 null
**解决**: 确保在 HttpProvider 内使用 AuthProvider

```typescript
// App.tsx
<HttpProvider>
  <AuthProvider>
    <App />
  </AuthProvider>
</HttpProvider>
```

### 2. 状态不同步

**原因**: 多个状态管理系统冲突
**解决**: 统一使用单一状态源

```typescript
// 避免
const { loading } = useHttp();
const [authState, setAuthState] = useState({ loading: false });

// 推荐
const [authState, setAuthState] = useState({ loading: false });
```

### 3. Token 过期处理

**当前问题**: 没有自动刷新机制
**建议方案**:

```typescript
// 添加 token 刷新逻辑
const refreshToken = (): Observable<LoginResponse> => {
  const refreshToken = localStorage.getItem('refresh_token');
  return http.post('/auth/refresh', { refreshToken });
};

// 在请求拦截器中处理 401 错误
http.interceptors.response.use(
  response => response,
  error => {
    if (error.status === 401) {
      return refreshToken().pipe(
        switchMap(() => http.request(error.config))
      );
    }
    return throwError(error);
  }
);
```

## 扩展指南

### 1. 添加新的认证方法

```typescript
// 扩展 AuthContextType
type AuthContextType = {
  // 现有方法...
  loginWithGoogle: () => Observable<LoginResponse>;
  loginWithWechat: () => Observable<LoginResponse>;
};

// 实现新方法
const loginWithGoogle = (): Observable<LoginResponse> => {
  // Google OAuth 登录逻辑
};
```

### 2. 添加权限检查

```typescript
// 添加权限检查 hook
export const usePermission = (permission: string): boolean => {
  const auth = useAuth();
  
  return useMemo(() => {
    if (!auth?.authState.role) return false;
    return checkPermission(auth.authState.role, permission);
  }, [auth?.authState.role, permission]);
};

// 使用示例
const canDelete = usePermission('DELETE_POST');
```

### 3. 添加多语言支持

```typescript
// 错误消息国际化
const getErrorMessage = (error: string, locale: string): string => {
  const messages = {
    'zh': {
      'LOGIN_FAILED': '登录失败',
      'NETWORK_ERROR': '网络错误'
    },
    'en': {
      'LOGIN_FAILED': 'Login failed',
      'NETWORK_ERROR': 'Network error'
    }
  };
  
  return messages[locale][error] || error;
};
```

## 部署注意事项

### 1. 环境变量配置

```typescript
// 确保所有环境都正确配置
const apiConfig = {
  baseURL: process.env.REACT_APP_API_URL,
  timeout: process.env.REACT_APP_API_TIMEOUT || 10000
};
```

### 2. 安全配置

```typescript
// 生产环境安全检查
if (process.env.NODE_ENV === 'production') {
  // 禁用控制台日志
  console.log = () => {};
  
  // 检查 HTTPS
  if (location.protocol !== 'https:') {
    location.replace('https:' + window.location.href.substring(window.location.protocol.length));
  }
}
```

### 3. 性能监控

```typescript
// 添加性能监控
const trackAuthEvent = (event: string, data?: any) => {
  if (typeof gtag !== 'undefined') {
    gtag('event', event, {
      custom_parameter: data
    });
  }
};

// 在关键位置调用
trackAuthEvent('login_attempt');
trackAuthEvent('login_success');
```

## 维护清单

### 定期检查项

- [ ] 清理未使用的依赖和代码
- [ ] 更新类型定义与后端 API 保持同步  
- [ ] 检查内存泄漏（使用 React Developer Tools）
- [ ] 验证错误处理覆盖所有场景
- [ ] 更新单元测试和集成测试
- [ ] 检查安全漏洞（npm audit）
- [ ] 性能测试（Lighthouse）

### 版本升级指南

1. **依赖更新**: 定期更新 RxJS、React 等核心依赖
2. **类型检查**: 确保 TypeScript 编译通过
3. **向后兼容**: 保持 API 接口稳定性
4. **文档更新**: 同步更新相关文档

这份开发者指南提供了维护和扩展 AuthProvider 所需的全部信息。在进行任何修改前，请确保理解现有的架构设计和最佳实践。