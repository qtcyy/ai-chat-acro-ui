# 后端接口集成指南

## 概述

本指南详细说明了 AuthProvider 与后端 Sa-Token 认证框架的集成实现，包括类型定义、API 调用和状态管理。

## 后端接口结构

### Sa-Token 响应格式

#### 登录接口响应
```java
// 后端 Java 代码
return SaResult.ok("登录成功")
    .set("token", StpUtil.getTokenValue())
    .set("userId", user.getId())
    .set("username", user.getUsername())
    .set("role", role)
    .set("sessionInfo", sessionInfo);
```

#### 对应前端类型定义
```typescript
type LoginResponse = {
  code: number;           // SaResult 状态码
  msg: string;            // 返回消息
  token: string;          // JWT token
  userId: string;         // 用户ID (必需)
  username: string;       // 用户名 (必需)
  role: string;           // 用户角色 (新增)
  sessionInfo?: any;      // 会话信息 (可选)
};
```

### 登录检查接口

#### CheckLoginResponse 类型
```typescript
type CheckLoginResponse = {
  code: number;       // 200 表示成功
  msg: string;        // "success" 表示验证通过
  token: string;      // 当前有效 token
  userId: string;     // 用户唯一标识
  username: string;   // 用户名
  role: string;       // 用户角色
};
```

## API 调用实现

### 1. 登录函数实现

```typescript
const login = (): Observable<LoginResponse> => {
  if (!http) {
    return throwError(() => "HTTP client is not available");
  }

  const url = apiConfig.getChatManageUrl("/user/login");
  const postBody = combineLatest([username$, password$]).pipe(
    take(1),  // 防止内存泄漏
    map(([username, password]) => ({ username, password }))
  );

  return postBody.pipe(
    switchMap((body) => {
      setAuthState(pre => ({ ...pre, loading: true, error: null }));
      return http.post<LoginResponse>(url, body);
    }),
    tap((response) => {
      // 检查响应状态码
      if (response.code === 200) {
        // 存储 token（需要安全改进）
        localStorage.setItem("token", response.token);
        
        // 更新认证状态
        setAuthState(pre => ({
          ...pre,
          loading: false,
          isAuthed: true,
          username: response.username,
          role: response.role,
        }));
      } else {
        throw new Error(response.msg || "登录失败");
      }
    }),
    catchError((error) => {
      const loginError = handleLoginError(error.message || error);
      setAuthState(pre => ({
        ...pre,
        loading: false,
        error: loginError
      }));
      return throwError(() => loginError);
    })
  );
};
```

### 2. 自动登录检查实现

```typescript
const checkLogin = (): Observable<CheckLoginResponse> => {
  if (!http) {
    return throwError(() => "Http not init");
  }
  
  const url = apiConfig.getChatManageUrl("/user/checkLogin");
  return http.get<CheckLoginResponse>(url).pipe(loadingOperator);
};

// 在组件初始化时自动检查登录状态
useEffect(() => {
  const subscription = checkLogin().subscribe({
    next: (value) => {
      if (value.code === 200 && value.msg === "success") {
        setAuthState(pre => ({
          ...pre,
          isAuthed: true,
          role: value.role,
          username: value.username,
        }));
      } else {
        setAuthState(pre => ({
          ...pre,
          isAuthed: false,
        }));
      }
    },
    // 注意：需要添加错误处理
  });

  return () => subscription.unsubscribe();
}, []);
```

## 状态管理结构

### AuthState 类型定义

```typescript
type AuthState = {
  loading: boolean;       // 加载状态
  error: AuthError | null; // 错误信息
  isAuthed: boolean;      // 认证状态
  username: string | null; // 用户名（新增）
  role: string | null;    // 用户角色（新增）
};
```

### 错误处理类型

```typescript
type AuthError = {
  message: string;
  code: number;
};
```

## API 配置

### 接口端点配置

```typescript
// 在 apiConfig 中定义的接口
const API_ENDPOINTS = {
  LOGIN: "/user/login",
  CHECK_LOGIN: "/user/checkLogin",
  LOGOUT: "/user/logout"
};
```

### HTTP 客户端配置

```typescript
// 使用 useHttp hook 进行 HTTP 调用
const http = useHttp();
const { loadingOperator } = HttpLoading();
```

## 集成最佳实践

### 1. 响应状态码检查

```typescript
// 统一的响应状态检查
const isSuccessResponse = (response: BaseResponse): boolean => {
  return response.code === 200 && response.msg === "success";
};
```

### 2. 错误处理策略

```typescript
const handleLoginError = (error: string): AuthError => {
  return {
    message: error,
    code: error.includes("网络") ? 0 : 400
  };
};
```

### 3. 加载状态管理

```typescript
// 统一的加载状态设置
const setLoadingState = (loading: boolean) => {
  setAuthState(prev => ({
    ...prev,
    loading
  }));
};
```

## 安全考虑

### Token 存储安全

**当前实现（需要改进）：**
```typescript
localStorage.setItem("token", response.token);
```

**推荐实现：**
```typescript
// 选项1：使用 sessionStorage（更安全）
sessionStorage.setItem("auth_token", response.token);

// 选项2：让后端设置 httpOnly cookie（最安全）
// 不需要客户端存储 token
```

### 敏感信息保护

**避免敏感信息泄露：**
```typescript
// 错误做法
console.log(response); // 可能包含敏感信息

// 正确做法
if (process.env.NODE_ENV === 'development') {
  console.log('Login success:', { 
    code: response.code, 
    username: response.username 
  });
}
```

## 使用示例

### 在组件中使用 AuthProvider

```typescript
import { useAuth } from '../hooks/auth/AuthProvider';

const LoginPage = () => {
  const authContext = useAuth();
  
  if (!authContext) {
    return <div>加载中...</div>;
  }
  
  const { login, authState } = authContext;
  
  const handleLogin = () => {
    login().subscribe({
      next: (response) => {
        console.log('登录成功:', response.username);
        // 处理成功逻辑
      },
      error: (error) => {
        console.error('登录失败:', error.message);
        // 处理错误逻辑
      }
    });
  };
  
  return (
    <div>
      <button 
        onClick={handleLogin}
        disabled={authState.loading}
      >
        {authState.loading ? '登录中...' : '登录'}
      </button>
      
      {authState.error && (
        <div className="error">
          {authState.error.message}
        </div>
      )}
    </div>
  );
};
```

## 测试策略

### 单元测试示例

```typescript
describe('AuthProvider', () => {
  it('应该正确处理登录成功响应', () => {
    const mockResponse: LoginResponse = {
      code: 200,
      msg: "登录成功",
      token: "mock-token",
      userId: "123",
      username: "testuser",
      role: "user"
    };
    
    // 测试登录逻辑
  });
  
  it('应该正确处理登录失败响应', () => {
    const mockErrorResponse: LoginResponse = {
      code: 401,
      msg: "用户名或密码错误",
      token: "",
      userId: "",
      username: "",
      role: ""
    };
    
    // 测试错误处理逻辑
  });
});
```

## 性能优化

### 1. 使用 take(1) 防止内存泄漏

```typescript
const postBody = combineLatest([username$, password$]).pipe(
  take(1),  // 只取一次值，避免持续订阅
  map(([username, password]) => ({ username, password }))
);
```

### 2. 正确清理订阅

```typescript
useEffect(() => {
  const subscription = someObservable.subscribe();
  
  return () => {
    subscription.unsubscribe();
  };
}, []);
```

### 3. 避免不必要的重新渲染

```typescript
// 使用 React.memo 优化组件
const AuthenticatedComponent = React.memo(({ user }) => {
  return <div>欢迎, {user.username}!</div>;
});
```

## 故障排除

### 常见问题及解决方案

1. **Token 过期处理**
```typescript
// 在 HTTP 拦截器中处理 token 过期
if (error.status === 401) {
  // 清除本地存储的 token
  localStorage.removeItem("token");
  // 重定向到登录页
  navigate("/login");
}
```

2. **网络连接问题**
```typescript
catchError((error) => {
  if (!navigator.onLine) {
    return throwError(() => new Error("网络连接断开，请检查您的网络设置"));
  }
  return throwError(() => error);
})
```

3. **并发登录问题**
```typescript
// 使用 shareReplay 避免重复请求
const login$ = login().pipe(
  shareReplay(1)
);
```

## 总结

这份集成指南提供了完整的后端接口集成实现方案，包括类型安全、错误处理、状态管理和性能优化。在实施时请特别注意安全性问题，确保敏感信息得到适当保护。